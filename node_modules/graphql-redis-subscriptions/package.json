{
  "_from": "graphql-redis-subscriptions",
  "_id": "graphql-redis-subscriptions@2.1.0",
  "_inBundle": false,
  "_integrity": "sha512-edur8YlwIsjk9K1Ao8vgEQkNKvt11FCTlOIFfxMKYIHOVv4zMvDsv7fs282LxMJBJGDCDDcdc1c5iKj0BjXO+Q==",
  "_location": "/graphql-redis-subscriptions",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "graphql-redis-subscriptions",
    "fetchSpec": "latest",
    "name": "graphql-redis-subscriptions",
    "raw": "graphql-redis-subscriptions",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/graphql-redis-subscriptions/-/graphql-redis-subscriptions-2.1.0.tgz",
  "_shasum": "cd7804d9524c84800deaf81632539f3f2693ebf5",
  "_shrinkwrap": null,
  "_spec": "graphql-redis-subscriptions",
  "_where": "/home/jcgp/Escritorio/apolloServer1",
  "author": {
    "name": "David Yahalomi"
  },
  "bugs": {
    "url": "https://github.com/davidyaha/graphql-redis-subscriptions/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "MichaÅ‚ Lytek",
      "url": "https://github.com/19majkel94"
    }
  ],
  "dependencies": {
    "ioredis": "^4.6.3",
    "iterall": "^1.2.2"
  },
  "deprecated": false,
  "description": "A graphql-subscriptions PubSub Engine using redis",
  "devDependencies": {
    "@types/chai": "^4.1.6",
    "@types/chai-as-promised": "7.1.0",
    "@types/ioredis": "4.0.3",
    "@types/mocha": "^5.2.5",
    "@types/node": "7.0.19",
    "@types/simple-mock": "0.8.0",
    "chai": "^4.2.0",
    "chai-as-promised": "^7.1.1",
    "graphql": "^14.1.1",
    "graphql-subscriptions": "^1.0.0",
    "ioredis": "^4.6.3",
    "istanbul": "1.0.0-alpha.2",
    "mocha": "^5.2.0",
    "remap-istanbul": "^0.12.0",
    "simple-mock": "^0.8.0",
    "tslint": "^5.8.0",
    "typescript": "^3.1.1"
  },
  "homepage": "https://github.com/davidyaha/graphql-redis-subscriptions",
  "keywords": [
    "apollo",
    "graphql",
    "redis",
    "subscriptions"
  ],
  "license": "MIT",
  "main": "dist/index.js",
  "name": "graphql-redis-subscriptions",
  "optionalDependencies": {
    "ioredis": "^4.6.3"
  },
  "peerDependencies": {
    "graphql-subscriptions": "^1.0.0"
  },
  "readme": "# graphql-redis-subscriptions\n\n[![Greenkeeper badge](https://badges.greenkeeper.io/davidyaha/graphql-redis-subscriptions.svg)](https://greenkeeper.io/)\n[![Build Status](https://travis-ci.org/davidyaha/graphql-redis-subscriptions.svg?branch=master)](https://travis-ci.org/davidyaha/graphql-redis-subscriptions)\n\nThis package implements the PubSubEngine Interface from the [graphql-subscriptions](https://github.com/apollographql/graphql-subscriptions) package and also the new AsyncIterator interface. \nIt allows you to connect your subscriptions manager to a Redis Pub Sub mechanism to support \nmultiple subscription manager instances.\n\n## Installation\nAt first, install the `graphql-redis-subscriptions` package: \n```\nnpm install graphql-redis-subscriptions\n```\n\nAs the [graphql-subscriptions](https://github.com/apollographql/graphql-subscriptions) package is declared as a peer dependency, you might receive warning about an unmet peer dependency if it's not installed already by one of your other packages. In that case you also need to install it too:\n```\nnpm install graphql-subscriptions\n```\n   \n## Using as AsyncIterator\n\nDefine your GraphQL schema with a `Subscription` type:\n\n```graphql\nschema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription\n}\n\ntype Subscription {\n    somethingChanged: Result\n}\n\ntype Result {\n    id: String\n}\n```\n\nNow, let's create a simple `RedisPubSub` instance:\n\n```javascript\nimport { RedisPubSub } from 'graphql-redis-subscriptions';\nconst pubsub = new RedisPubSub();\n```\n\nNow, implement your Subscriptions type resolver, using the `pubsub.asyncIterator` to map the event you need:\n\n```javascript\nconst SOMETHING_CHANGED_TOPIC = 'something_changed';\n\nexport const resolvers = {\n  Subscription: {\n    somethingChanged: {\n      subscribe: () => pubsub.asyncIterator(SOMETHING_CHANGED_TOPIC),\n    },\n  },\n}\n```\n\n> Subscriptions resolvers are not a function, but an object with `subscribe` method, that returns `AsyncIterable`.\n\nCalling the method `asyncIterator` of the `RedisPubSub` instance will send redis a `SUBSCRIBE` message to the topic provided and will return an `AsyncIterator` binded to the RedisPubSub instance and listens to any event published on that topic.\nNow, the GraphQL engine knows that `somethingChanged` is a subscription, and every time we will use `pubsub.publish` over this topic, the `RedisPubSub` will `PUBLISH` the event over redis to all other subscribed instances and those in their turn will emit the event to GraphQL using the `next` callback given by the GraphQL engine.\n\n```js\npubsub.publish(SOMETHING_CHANGED_TOPIC, { somethingChanged: { id: \"123\" }});\n```\n\n## Dynamically create a topic based on subscription args passed on the query:\n\n```javascript\nexport const resolvers = {\n  Subscription: {\n    somethingChanged: {\n      subscribe: (_, args) => pubsub.asyncIterator(`${SOMETHING_CHANGED_TOPIC}.${args.relevantId}`),\n    },\n  },\n}\n```\n\n## Using both arguments and payload to filter events\n\n```javascript\nimport { withFilter } from 'graphql-subscriptions';\n\nexport const resolvers = {\n  Subscription: {\n    somethingChanged: {\n      subscribe: withFilter(\n        (_, args) => pubsub.asyncIterator(`${SOMETHING_CHANGED_TOPIC}.${args.relevantId}`),\n        (payload, variables) => payload.somethingChanged.id === variables.relevantId,\n      ),\n    },\n  },\n}\n```\n\n## Creating the Redis Client\n\nFor production usage, it is recommended to send a Redis client from the using code.\n\n```javascript\nimport { RedisPubSub } from 'graphql-redis-subscriptions';\nimport * as Redis from 'ioredis';\n\nconst options = {\n  host: REDIS_DOMAIN_NAME,\n  port: PORT_NUMBER,\n  retry_strategy: options => {\n    // reconnect after\n    return Math.max(options.attempt * 100, 3000);\n  }\n};\n\nconst pubsub = new RedisPubSub({\n  ...,\n  publisher: new Redis(options),\n  subscriber: new Redis(options)\n});\n```\n\nYou can learn more on the `ioredis` package [here](https://github.com/luin/ioredis).\n\n## Passing redis options object\n\nThe basic usage is great for development and you will be able to connect to a Redis server running on your system seamlessly.\nBut for any production usage you should probably pass in a redis options object.\n \n```javascript\nimport { RedisPubSub } from 'graphql-redis-subscriptions';\n\nconst pubsub = new RedisPubSub({\n  connection: {\n    host: REDIS_DOMAIN_NAME,\n    port: PORT_NUMBER,\n    retry_strategy: options => {\n      // reconnect after\n      return Math.max(options.attempt * 100, 3000);\n    }\n  }\n});\n```\n\nYou can learn more on the redis options object [here](https://github.com/luin/ioredis/blob/master/API.md#new_Redis_new).\n\n## Using a custom reviver\n\nBy default, Javascript objects are serialized using the `JSON.stringify` and `JSON.parse` methods.\nFor handling custom objects, you may pass your own reviver function to `JSON.parse`.\n\n```javascript\nimport { RedisPubSub } from 'graphql-redis-subscriptions';\n\nconst dateReviver = (key, value) => {\n  const isISO8601Z = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/;\n  if (typeof value === 'string' && isISO8601Z.test(value)) {\n    const tempDateNumber = Date.parse(value);\n    if (!isNaN(tempDateNumber)) {\n      return new Date(tempDateNumber);\n    }\n  }\n  return value;\n};\n\nconst pubSub = new RedisPubSub({ ..., reviver: dateReviver });\n\npubSub.publish('Test', {\n  validTime: new Date(),\n  invalidTime: '2018-13-01T12:00:00Z'\n});\npubSub.subscribe('Test', message => {\n  message.validTime; // Javascript Date\n  message.invalidTime; // string\n});\n```\n\n## Old Usage (Deprecated)\n\n```javascript\nimport { RedisPubSub } from 'graphql-redis-subscriptions';\nconst pubsub = new RedisPubSub();\nconst subscriptionManager = new SubscriptionManager({\n  schema,\n  pubsub,\n  setupFunctions: {},\n});\n```\n\n## Using Trigger Transform (Deprecated)\n\nRecently, graphql-subscriptions package added a way to pass in options to each call of subscribe.\nThose options are constructed via the setupFunctions object you provide the Subscription Manager constructor.\nThe reason for graphql-subscriptions to add that feature is to allow pub sub engines a way to reduce their subscription set using the best method of said engine.\nFor example, Meteor's live query could use Mongo selector with arguments passed from the subscription like the subscribed entity id.\nFor Redis, this could be a bit more simplified, but much more generic.\nThe standard for Redis subscriptions is to use dot notations to make the subscription more specific.\nThis is only the standard but I would like to present an example of creating a specific subscription using the channel options feature.\n\nFirst I create a simple and generic trigger transform \n```javascript\nconst triggerTransform = (trigger, {path}) => [trigger, ...path].join('.');\n```\n\nThen I pass it to the `RedisPubSub` constructor.\n```javascript\nconst pubsub = new RedisPubSub({\n  triggerTransform,\n});\n```\nLastly, I provide a setupFunction for `commentsAdded` subscription field.\nIt specifies one trigger called `comments.added` and it is called with the channelOptions object that holds `repoName` path fragment.\n```javascript\nconst subscriptionManager = new SubscriptionManager({\n  schema,\n  setupFunctions: {\n    commentsAdded: (options, {repoName}) => ({\n      'comments.added': {\n        channelOptions: {path: [repoName]},\n      },\n    }),\n  },\n  pubsub,\n});\n```\n\nWhen I call `subscribe` like this:\n```javascript\nconst query = `\n  subscription X($repoName: String!) {\n    commentsAdded(repoName: $repoName)\n  }\n`;\nconst variables = {repoName: 'graphql-redis-subscriptions'};\nsubscriptionManager.subscribe({query, operationName: 'X', variables, callback});\n```\n\nThe subscription string that Redis will receive will be `comments.added.graphql-redis-subscriptions`.\nThis subscription string is much more specific and means the the filtering required for this type of subscription is not needed anymore.\nThis is one step towards lifting the load off of the GraphQL API server regarding subscriptions.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidyaha/graphql-redis-subscriptions.git"
  },
  "scripts": {
    "benchmark": "npm run compile && mocha --reporter spec --full-trace ./dist/test/benchmark.js ",
    "compile": "tsc",
    "coverage": "node ./node_modules/istanbul/lib/cli.js cover _mocha -- --full-trace ./dist/test/tests.js",
    "integration": "npm run compile && mocha --reporter spec --full-trace ./dist/test/integration-tests.js ",
    "lint": "tslint --project ./tsconfig.json ./src/**/*.ts",
    "postcoverage": "remap-istanbul --input coverage/coverage.raw.json --type lcovonly --output coverage/lcov.info",
    "posttest": "npm run lint",
    "prepublishOnly": "npm run test",
    "pretest": "npm run compile",
    "test": "npm run testonly -- && npm run integration --",
    "testonly": "mocha --reporter spec --full-trace ./dist/test/tests.js ",
    "watch": "tsc -w"
  },
  "typescript": {
    "definition": "dist/index.d.ts"
  },
  "typings": "dist/index.d.ts",
  "version": "2.1.0"
}
